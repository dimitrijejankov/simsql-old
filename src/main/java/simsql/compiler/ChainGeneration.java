

/*****************************************************************************
 *                                                                           *
 *  Copyright 2014 Rice University                                           *
 *                                                                           *
 *  Licensed under the Apache License, Version 2.0 (the "License");          *
 *  you may not use this file except in compliance with the License.         *
 *  You may obtain a copy of the License at                                  *
 *                                                                           *
 *      http://www.apache.org/licenses/LICENSE-2.0                           *
 *                                                                           *
 *  Unless required by applicable law or agreed to in writing, software      *
 *  distributed under the License is distributed on an "AS IS" BASIS,        *
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *
 *  See the License for the specific language governing permissions and      *
 *  limitations under the License.                                           *
 *                                                                           *
 *****************************************************************************/


/**
 * 
 */
package simsql.compiler;

import simsql.compiler.timetable.TableDependencyGraph;
import simsql.compiler.timetable.TimeTableNode;

import java.util.*;


/**
 * @author Bamboo
 *
 */
public class ChainGeneration
{
	private Topologic topologic;
	/*
	 * The ruleMap records for each random table, which random tables are needed.
	 */
	private HashMap<String, HashSet<String>> ruleMap;
	/*
	 * The simulateTableMap saves for each time tick, the list of "TABLE" at this time, with the corresponding 
	 * tables generated by "TABLE".
	 */
	private HashMap<Integer, TableByTime> simulateTableMap;
	private ArrayList<String> startPointList;
	
	private int startTimeTick;
    private LinkedList<TimeTableNode> requiredTables;
	
	public ChainGeneration(Topologic topologic,
			               int maxLoop,
                           LinkedList<TimeTableNode> requiredTables)
	{
        this.topologic = topologic;
        this.requiredTables = requiredTables;

		this.ruleMap = new HashMap<String, HashSet<String>>();
        this.simulateTableMap = new HashMap<Integer, TableByTime>();
        this.startPointList = new ArrayList<String>();

		instantiateChain(0, maxLoop);
	}

	public ArrayList<String> getTopologicalList(int start, int end)
	{
	    /*
		HashMap<Integer, TableByTime> chain = getChainByTime(-1, end);
		ArrayList<String> startPoint = this.getStartPoint();
		ArrayList<String> sortList = topologicalSort(chain, startPoint);
		ArrayList<String> resultList = new ArrayList<String>();


        for (String table : sortList) {
            if (this.simulateTableMap.get(start).getTableSet().contains(table)) {
                resultList.add(table);
            }
        }
        */

		return new ArrayList<String>(this.simulateTableMap.get(start).getTableSet());
	}
	
	/*
	 * Such random tables which are generated without referring to other random tables
	 */
	public ArrayList<String> getStartPoint()
	{
		return startPointList;
	}
	
	public HashMap<Integer, TableByTime> getChainByTime(int start, int end)
	{
		HashMap<Integer, TableByTime> resultChain = new HashMap<Integer, TableByTime>();
		for(int i = start; i <= end; i++)
		{
			if(simulateTableMap.containsKey(i))
			{
				TableByTime tempTable = simulateTableMap.get(i);
				resultChain.put(i, tempTable.copy());
			}
		}
		
		return resultChain;
	}
	
	private void instantiateChain(int start, int end)
	{

        TableDependencyGraph dependencyGraph = new TableDependencyGraph(requiredTables, topologic.getBackwardEdges());

		/*
		 * 1. starting point
		 */
		startPointList = dependencyGraph.getStartingPoint();

        /*
		 * 2. ruleMap
		 */
        ruleMap = dependencyGraph.generateRuleMap();

        /*
		 * 3. simulateTableMap
		 */
        simulateTableMap = dependencyGraph.extractSimulateTableMap();

        /*
		 * 4. startTimeTick
		 */
        startTimeTick = 0;
	}

	
	/*
	 * If it is the baseline table, then it returns the version of this table;
	 */
	public int getVersionFromConstantTable(String table)
	{
		int start = table.indexOf("[");
		int end = table.indexOf("]");
		String index = table.substring(start+1, end);
		
		return Integer.parseInt(index);
	}

	
	public HashMap<Integer, TableByTime> getSimulateTableMap() {
		return simulateTableMap;
	}
	
	private ArrayList<String> topologicalSort(HashMap<Integer, TableByTime> chain, ArrayList<String> startPoint)
	{
		ArrayList<String> resultList = new ArrayList<String>();
		
		ArrayList<String> nodeList = new ArrayList<String>();
		HashMap<String, Integer> childrenNumMap = new HashMap<String, Integer>();
		
		Integer []index = new Integer[chain.size()];
		chain.keySet().toArray(index);
		Arrays.sort(index);
		
		/*
		 * 1. start point
		 */
		for(int i = 0; i < startPoint.size(); i++)
		{
			String starttable = startPoint.get(i);
			childrenNumMap.put(starttable, 0);
		}
		
		/*
		 * 2. Get all the table and its parents number in topological order.
		 */
		for(int i = 0; i < index.length; i++)
		{
			TableByTime tableByTime = chain.get(index[i]);
			
			HashSet<String> tableList = tableByTime.getTableSet();
			HashMap<String, HashSet<String>> timeMap = tableByTime.getTimeMap();
			
			for(String tempTable: tableList)
			{
				if(!nodeList.contains(tempTable))
				{
					nodeList.add(tempTable);
				}
			}
			
			for(String s: timeMap.keySet())
			{
				HashSet<String> tempList = timeMap.get(s);
				
				for(String value: tempList)
				{
					addOne(childrenNumMap, value);
				}
			}
		}
		
		boolean accessed[] = new boolean[nodeList.size()];
		for(int i = 0; i < nodeList.size(); i++)
		{
			accessed[i] = false;
		}
		
		for(int i = 0; i < nodeList.size(); i++)
		{
			//find the node with no parents
			HashMap<String, Integer> potentialStringMap = new HashMap<String, Integer>();
			
			for(int j = 0; j < nodeList.size(); j++)
			{
				String temp = nodeList.get(j);
				
				if(childrenNumMap.containsKey(temp)&& childrenNumMap.get(temp) == 0 && !accessed[j])
				{
					potentialStringMap.put(temp, j);
				}
			}
			
			//get j
			if(potentialStringMap.isEmpty())
			{
				resultList.clear();
				System.err.println("Circles in the graph");
				break;
			}
			else
			{
				int min = Integer.MAX_VALUE;
				String minTable = null;
				
				for(String s: potentialStringMap.keySet())
				{
					if(min > this.getVersionFromConstantTable(s))
					{
						min = this.getVersionFromConstantTable(s);
						minTable = s;
					}
				}
				
				resultList.add(minTable);
				accessed[potentialStringMap.get(minTable)] = true;
				
				int time = min;
				
				TableByTime tableByTime = chain.get(time);
				if(tableByTime != null)
				{
					HashMap<String, HashSet<String>> timeMap = tableByTime.getTimeMap();
					if(timeMap.containsKey(minTable))
					{
						HashSet<String> targetList = timeMap.get(minTable);
						for(String element: targetList)
						{
							reduceOne(childrenNumMap, element);
						}
					}
				}
			}
		}
		
		return resultList;
	}
	
	public void addOne(HashMap<String, Integer> childrenNumMap, String key)
	{
		if(childrenNumMap.containsKey(key))
		{
			int value = childrenNumMap.get(key);
			childrenNumMap.put(key, value + 1);
		}
		else
		{
			childrenNumMap.put(key, 1);
		}
	}
	
	public void reduceOne(HashMap<String, Integer> childrenNumMap, String key)
	{
		if(childrenNumMap.containsKey(key))
		{
			int value = childrenNumMap.get(key);
			childrenNumMap.put(key, value - 1);
		}
	}
	
	public int getMinimumTimeTick()
	{
		return startTimeTick;
	}

	public int getTickForTable(String tableName) {

		for(int tick : simulateTableMap.keySet()){
			if(simulateTableMap.get(tick).getTableSet().contains(tableName)){
			    return tick;
            }
		}

		throw new RuntimeException("Tick not found for table " + tableName + "!");
	}

	/**
	 * @return the ruleMap
	 */
	public HashMap<String, HashSet<String>> getRuleMap() {
		return ruleMap;
	}


	public int getMaxLoop() {
	    return simulateTableMap.size() - 1;
    }
}
